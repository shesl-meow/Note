> 学习途径：
>
> - 欧阳星明、华中科技大学出版社 《数字逻辑》

# 同步时序逻辑电路设计

设计的一般步骤：

![circuit-design-step](./circuit-design-step.svg)

# 完全确定同步时序逻辑电路设计

## 1. 形成原始状态图和原始状态表

一般步骤：

1. 确定电路模型：`Mealy` 模型、`Moore` 模型。
2. 设立初始状态
3. 根据需要记忆的信息增加新的状态
4. 确定各时刻电路的输出



例子：

> 设计一个模 5 可逆计数器，该电路有一个输入 x 和一个输出 Z。`x=0` 表示加控制信号，`x=1` 表示减控制信号。输出 `Z` 表示借位或进位信号。尝试建立该计数器的 `Mealy` 型原始状态图和状态表。

假设计数器的 5 个状态分别为 0、1、2、3、4，其中 0 表示初始状态。原始状态表如下所示：

| 当前状态 | 次态/输出 Z | 次态/输出 Z |
| -------- | ----------- | ----------- |
|          | **x=0**     | **x=1**     |
| 0        | 1/0         | 4/1         |
| 1        | 2/0         | 0/0         |
| 2        | 3/0         | 1/0         |
| 3        | 4/0         | 2/0         |
| 4        | 0/1         | 3/0         |

## 2. 状态化简

等效状态：

- 定义：假设状态 $$S_i$$ 和 $$S_j$$ 是完全确定状态表中的两个状态，如果对所有可能的输入序列，分别从 $$S_i$$ 和 $$S_j$$ 出发，所得到的输出响应序列完全相同，则状态 $$S_i$$ 和状态 $$S_j$$ 是等效的，记作 $$(S_i, S_j)$$。

- 判断方法：输入相同；次态相同、次态交错或为各自的现态、次态循环或为等效对。

等效类：若干个彼此等效的状态构成的集合。

最大等效类：不被任何别的等效类包含的等效类。



利用隐含表进行状态化简：

1. 作隐含表：一个边长为 `n-1` 的等腰直角三角形网格，纵向缺少第一个状态、横向缺少最后一个状态；
2. 寻找等效对：按照隐含表从上至下、从左至右的顺序逐一检查。检查结果分三种情况：明确等效的、明确不等效的、与其他状态有关；
3. 求出最大等效类：利用等效状态的传递性，求出各最大等效类；
4. 作出最简状态表：将每个最大类中的全部状态合并成一个状态。



例子：

> 化简下图的原始状态表：

> | 现态 | 次态/输出 | 次态/输出 |
> | ---- | --------- | --------- |
> |      | **x=0**   | **x=1**   |
> | A    | C/0       | B/1       |
> | B    | F/0       | A/1       |
> | C    | F/0       | G/0       |
> | D    | D/1       | E/0       |
> | E    | C/0       | E/1       |
> | F    | C/0       | G/0       |
> | G    | C/1       | D/0       |

化简结果如下图：

| 现态 | 次态/输出 | 次态/输出 |
| ---- | --------- | --------- |
|      | **x=0**   | **x=1**   |
| a    | b/0       | a/1       |
| b    | b/0       | d/0       |
| c    | c/1       | a/0       |
| d    | b/1       | c/0       |

## 3. 状态编码

状态编码：

- 定义：指给最简状态表中用字母或数字表示的状态，指定一个二进制代码，形成二进制状态表。也称状态分配或状态赋值。
- 任务：确定二进制代码的位数；寻找一种最佳的或接近最佳的状态分配方案，以便使所设计的时序电路最简单

确定二进制代码位数：

- 若 m 为二进制代码位数，n 为状态总数：$$2^{m-1} < n \le 2^m$$

相邻编码法：

- 基本思想：在选择状态编码时，尽可能有利于激励函数和输出函数的化简。

- 原则如下：

  1. **在相同输入条件下，具有相同次态的现态**应该尽可能分配相邻的二进制代码；

  2. **在相邻输入条件下，在同一现态的次态**应尽可能分配相邻的二进制代码；

  3. **输出完全相同的现态**应尽可能分配相邻的二进制代码。

- *NOTICE*：A、B 相邻：$$\displaystyle \sum_{bit=1} (A \oplus B) = 1$$



例子：

> 给下面的状态表进行状态编码：

> | 现态 | 次态/输出 | 次态/输出 |
> | ---- | --------- | --------- |
> |      | **x=0**   | **x=1**   |
> | A    | C/0       | B/0       |
> | B    | A/0       | A/1       |
> | C    | A/1       | D/1       |
> | D    | D/0       | C/0       |

二进制代码位数为 m，则 $$m = ceil[log_{2}4] = 2$$

相邻编码法：

- 假定 A 是起始状态，则：`code(A) = 00`；
- 根据`原则一`，BC 应该具有相邻的二进制代码；
- 根据`原则二`，BC、AD、CD 应该具有相邻的二进制代码，`code(D) = 10`，`code(C) = 11`，`code(B) = 01`
- 分配完了不用看`原则三`了

所以二进制状态表如下图所示：

| 现态    | 现态    | 次态/输出 | 次态/输出 |
| ------- | ------- | --------- | --------- |
| $$y_2$$ | $$y_1$$ | x=0       | x=1       |
| 0       | 0       | 11/0      | 01/0      |
| 0       | 1       | 00/0      | 00/1      |
| 1       | 1       | 00/1      | 10/1      |
| 1       | 0       | 10/0      | 11/0      |

## 4. 确定激励函数和输出函数

我们知道四种种控触发器的激励表：

R-S 触发器：

| $$Q^n$$ | $$Q^{n+1}$$ | 功能        | R    | S    |
| ------- | ----------- | ----------- | ---- | ---- |
| 0       | 0           | 置 0 或保持 | d    | 0    |
| 0       | 1           | 置 1        | 0    | 1    |
| 1       | 0           | 置 0        | 1    | 0    |
| 1       | 1           | 置 1 或保持 | 0    | d    |

D 触发器：

| $$Q^n$$ | $$Q^{n+1}$$ | 功能 | D    |
| ------- | ----------- | ---- | ---- |
| 0       | 0           | 置 0 | 0    |
| 0       | 1           | 置 1 | 1    |
| 1       | 0           | 置 0 | 0    |
| 1       | 1           | 置 1 | 1    |

J-K 触发器：

| $$Q^n$$ | $$Q^{n+1}$$ | 功能        | J    | K    |
| ------- | ----------- | ----------- | ---- | ---- |
| 0       | 0           | 置 0 或保持 | 0    | d    |
| 0       | 1           | 置 1 或计数 | 1    | d    |
| 1       | 0           | 置 0 或计数 | d    | 1    |
| 1       | 1           | 置 1 或保持 | d    | 0    |

T 触发器：

| $$Q^n$$ | $$Q^{n+1}$$ | 功能 | T    |
| ------- | ----------- | ---- | ---- |
| 0       | 0           | 保持 | 0    |
| 0       | 1           | 计数 | 1    |
| 1       | 0           | 计数 | 1    |
| 1       | 1           | 保持 | 0    |

根据二进制状态表和触发器的激励表，求激励函数和输出函数的最简表达式一般分为两步：

1. 首先列出激励函数和输出函数真值表；

2. 然后画出激励函数和输出函数卡诺图，化简后写出最简表达式。

*PostScript:* 除此之外，还可以根据二进制状态表和触发器的次态方程确定，见书本 P142



例子：

> 用 J-K 触发器和适当的门电路实现下表所示的而今hi状态表的功能

> | 现态    | 现态    | 次态/输出 | 次态/输出 |
> | ------- | ------- | --------- | --------- |
> | $$y_2$$ | $$y_1$$ | x=0       | x=1       |
> | 0       | 0       | 11/0      | 01/0      |
> | 0       | 1       | 00/0      | 00/1      |
> | 1       | 1       | 00/1      | 10/1      |
> | 1       | 0       | 01/0      | 11/0      |

作出激励函数和输出状态真值表：

| x    | $$y_2$$ | $$y_1$$ | $$J_2$$ | $$K_2$$ | $$J_1$$ | $$K_1$$ | Z    |
| ---- | ------- | ------- | ------- | ------- | ------- | ------- | ---- |
| 0    | 0       | 0       | 1       | d       | 1       | d       | 0    |
| 0    | 0       | 1       | 0       | d       | d       | 1       | 0    |
| 0    | 1       | 0       | d       | 1       | 1       | d       | 0    |
| 0    | 1       | 1       | d       | 1       | d       | 1       | 1    |
| 1    | 0       | 0       | 0       | d       | 1       | d       | 0    |
| 1    | 0       | 1       | 0       | d       | d       | 1       | 1    |
| 1    | 1       | 0       | d       | 0       | 1       | d       | 0    |
| 1    | 1       | 1       | d       | 0       | d       | 1       | 1    |

对 $$J_2, K_2, J_1, K_1, Z$$ 做出卡诺图，并且化简，可以得到下面的式子：$$\displaystyle \begin{cases} J_2 = \overline{x} \cdot \overline{y_1} \\ K_2 = \overline{x} \\ J_1 = K_1 = 1 \\ Z = (y_2 + x) \cdot y_1 \end{cases}$$

然后就可以画出电路图了。

# 不完全确定同步时序逻辑电路设计

（不想看了）