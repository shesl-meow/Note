# 相关概念

## File descriptor &rarr; 文件描述符

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向[内核](https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8)为每一个[进程](https://zh.wikipedia.org/wiki/%E8%BF%9B%E7%A8%8B)所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在[程序设计](https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于[UNIX](https://zh.wikipedia.org/wiki/UNIX)、[Linux](https://zh.wikipedia.org/wiki/Linux)这样的操作系统。

每个Unix进程（除了可能的[守护进程](https://zh.wikipedia.org/wiki/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B)）应均有三个标准的[POSIX](https://zh.wikipedia.org/wiki/POSIX)文件描述符，对应于三个标准流：`stdin`，`stdout` 与 `stderr`。

## Daemon &rarr; 守护进程

守护进程是在后台运行不受终端控制的进程（如输入、输出等），一般的网络服务都是以守护进程的方式运行。守护进程脱离终端的主要原因有两点：

1. 用来启动守护进程的终端在启动守护进程之后，需要执行其他任务。
2. （如其他用户登录该终端后，以前的守护进程的错误信息不应出现）由终端上的一些键所产生的信号（如中断信号），不应对以前从该终端上启动的任何守护进程造成影响。要注意守护进程与后台运行程序（即加 `＆` 启动的程序）的区别。

创建守护进程需要通过以下的过程：

1. 调用 fork 创建子进程。父进程终止，让子进程在后台继续执行。
2. 子进程调用 setsid 产生新会话期并失去控制终端调用 setsid() 使子进程进程成为新会话组长和新的进程组长，同时失去控制终端。
3. 忽略 SIGHUP 信号。因为会话组长进程终止会向其他进程发该信号，造成其他进程终止。
4. 调用 fork 再创建子进程。子进程终止，子子进程继续执行，由于子子进程不再是会话组长，从而禁止进程重新打开控制终端。
5.  改变当前工作目录为根目录。一般将工作目录改变到根目录，这样进程的启动目录也可以被卸掉。
6. 关闭打开的文件描述符，打开一个空设备，并复制到标准输出和标准错误上。 避免调用的一些库函数依然向屏幕输出信息。
7. 重设文件创建掩码清除从父进程那里继承来的文件创建掩码，设为0。
8. 用 `openlog` 函数建立与 `syslogd` 的连接。

这些 `Daemon` 服务的名称被创建之后，被挂上 Linux 使用时，通常在服务的名称之后会加上一个 `d`。

